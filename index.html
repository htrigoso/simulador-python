<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js – Scooter en Curva</title>
    <style>
      :root {
        --bg-1: #0f1020;
        --bg-2: #171a2f;
        --accent: #f4d35e;
        --accent-2: #ee964b;
        --text: #f8f8ff;
        --muted: #b8c0ff;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: radial-gradient(circle at 20% 20%, #1f2138 0%, var(--bg-1) 40%, var(--bg-2) 100%);
        color: var(--text);
        font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
      }
      #ui {
        position: absolute;
        top: 16px;
        left: 16px;
        padding: 14px 16px;
        background: rgba(15, 16, 32, 0.75);
        border: 1px solid rgba(244, 211, 94, 0.35);
        border-radius: 12px;
        backdrop-filter: blur(6px);
        max-width: 320px;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
      }
      #ui h1 {
        margin: 0 0 8px 0;
        font-size: 18px;
        letter-spacing: 0.5px;
      }
      #ui p {
        margin: 0 0 10px 0;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
      }
      label {
        font-size: 12px;
        width: 96px;
        color: var(--muted);
      }
      input[type="range"] {
        flex: 1;
        accent-color: var(--accent);
      }
      .value {
        width: 56px;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
      #legend {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <h1>Simulación 3D: Scooter en Curva</h1>
      <p>Movimiento circular uniforme con inclinación estimada por &theta; = atan(v² / rg).</p>
      <div class="row">
        <label for="speed">Velocidad</label>
        <input id="speed" type="range" min="5" max="60" value="25" step="1" />
        <div class="value" id="speedVal">25 km/h</div>
      </div>
      <div class="row">
        <label for="radius">Radio</label>
        <input id="radius" type="range" min="4" max="40" value="12" step="1" />
        <div class="value" id="radiusVal">12 m</div>
      </div>
      <div id="legend">Usa el mouse para orbitar. Scroll para zoom.</div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

      const G = 9.81;
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0f1020, 20, 120);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(24, 16, 24);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 2, 0);

      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xfff4d6, 1.0);
      keyLight.position.set(10, 20, 6);
      scene.add(keyLight);

      const rimLight = new THREE.DirectionalLight(0x8ecae6, 0.6);
      rimLight.position.set(-20, 10, -14);
      scene.add(rimLight);

      const floorGeo = new THREE.CircleGeometry(45, 120);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x161a2a, roughness: 0.8, metalness: 0.05 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      const grid = new THREE.GridHelper(90, 90, 0x2b2f55, 0x1d1f3d);
      grid.position.y = 0.01;
      scene.add(grid);

      const trackGeo = new THREE.TorusGeometry(12, 0.12, 16, 120);
      const trackMat = new THREE.MeshStandardMaterial({ color: 0xf4d35e, metalness: 0.3, roughness: 0.3 });
      const track = new THREE.Mesh(trackGeo, trackMat);
      track.rotation.x = Math.PI / 2;
      track.position.y = 0.05;
      scene.add(track);

      function makeScooter() {
        const group = new THREE.Group();

        const deck = new THREE.Mesh(
          new THREE.BoxGeometry(2.1, 0.2, 0.5),
          new THREE.MeshStandardMaterial({ color: 0x35374b, metalness: 0.2, roughness: 0.6 })
        );
        deck.position.y = 0.25;
        group.add(deck);

        const column = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0x7077a1, metalness: 0.3, roughness: 0.5 })
        );
        column.position.set(0.7, 0.9, 0);
        group.add(column);

        const handle = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.08, 0.08),
          new THREE.MeshStandardMaterial({ color: 0x7077a1, metalness: 0.3, roughness: 0.5 })
        );
        handle.position.set(0.7, 1.45, 0);
        group.add(handle);

        const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.18, 20);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1f1f1f, roughness: 0.9 });

        const wheelBack = new THREE.Mesh(wheelGeo, wheelMat);
        wheelBack.rotation.z = Math.PI / 2;
        wheelBack.position.set(-0.8, 0.25, 0);
        group.add(wheelBack);

        const wheelFront = new THREE.Mesh(wheelGeo, wheelMat);
        wheelFront.rotation.z = Math.PI / 2;
        wheelFront.position.set(0.9, 0.25, 0);
        group.add(wheelFront);

        const rider = new THREE.Mesh(
          new THREE.CapsuleGeometry(0.28, 0.7, 4, 12),
          new THREE.MeshStandardMaterial({ color: 0xee964b, roughness: 0.4 })
        );
        rider.position.set(0.0, 1.4, 0);
        group.add(rider);

        return group;
      }

      const scooter = makeScooter();
      scene.add(scooter);

      const speedInput = document.getElementById("speed");
      const radiusInput = document.getElementById("radius");
      const speedVal = document.getElementById("speedVal");
      const radiusVal = document.getElementById("radiusVal");

      let radius = Number(radiusInput.value);
      let speedKmh = Number(speedInput.value);
      let speedMs = speedKmh / 3.6;
      let angle = 0;

      function updateTrack() {
        const newGeo = new THREE.TorusGeometry(radius, 0.12, 16, 160);
        track.geometry.dispose();
        track.geometry = newGeo;
      }

      function updateUI() {
        speedVal.textContent = `${speedKmh} km/h`;
        radiusVal.textContent = `${radius} m`;
      }

      function updateParams() {
        radius = Number(radiusInput.value);
        speedKmh = Number(speedInput.value);
        speedMs = speedKmh / 3.6;
        updateTrack();
        updateUI();
      }

      speedInput.addEventListener("input", updateParams);
      radiusInput.addEventListener("input", updateParams);
      updateParams();

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const omega = speedMs / Math.max(radius, 0.1);
        angle = (angle + omega * dt) % (Math.PI * 2);

        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        scooter.position.set(x, 0, z);

        const tangentAngle = angle + Math.PI / 2;
        scooter.rotation.set(0, -tangentAngle, 0);

        const lean = Math.atan((speedMs * speedMs) / (radius * G));
        scooter.rotation.z = -lean;

        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
